---
title: "Of mice and men"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo    = TRUE,
                      message = FALSE)
```


Looking at data from
Zhang *et al.*
Short-course chemotherapy with TMC207 and rifapentine in a murine model of
latent tuberculosis infection.
*American Journal of Respiratory and Critical Care Medicine* 184.6 (2011): 732-737.
[10.1164/rccm.201103-0397OC](https://doi.org/10.1164/rccm.201103-0397oc)

## Packages

```{r}
library(readxl)
library(dplyr)
library(purrr)
library(tidyr)
library(parallel)
library(bbmle)
```


## Utilitary functions

A function that adds proportions estimate and confidence interval to a data
frame from a column of successes and a column or trials:

```{r}
add_prop_est <- function(df, x, n, p = "est", l = "lwr", u = "upr", ...) {
  df |> 
    mutate(test   = map2({{ x }}, {{ n }}, prop.test, ...),
           "{p}" := map_dbl(test, ~ .x[["estimate"]]),
           conf   = map(test, ~ setNames(.x[["conf.int"]], c(l, u)))) |> 
    unnest_wider(conf) |> 
    select(- test)
}
```


## The data

```{r}
table2 <- read_excel("table 2 Zhang et al 2011.xlsx")
```

The data look like this:

```{r}
table2
```


## Analysis

Preparing the data for vizualization:

```{r}
table2a <- table2 |>
  add_prop_est(positive, total) |> 
  mutate_at("duration", jitter, factor = .2)
```

It looks like this:

```{r}
table2a
```

A function that adds proportion estimates and confidence intervals to a plot:

```{r}
add_data <- function(x, col) {
  table2a |> 
    filter(group == x) |> 
    with({
      points(duration, est, col = col)
      arrows(duration, lwr, duration, upr, .1, 90, 3, col)
    })
}
```

Preparing the data for modelling:

```{r}
treatments <- unique(table2$group)

t0_val <- 1e4

table2b <- bind_rows(
  table2,
  tibble(group = treatments, duration = 0, positive = t0_val, total = t0_val))
```

A function that adds the logistic model predictions to a plot:

```{r}
add_model <- function(x, col) {
  dt <- filter(table2b, group == x)
  df <- sum(dt$total)
  
  model <- glm(cbind(total - positive, total) ~ duration, binomial, dt)
  linkinv <- model$family$linkinv
  
  predictions <- tibble(duration = seq(0, 6, le = 512))
  
  preds <- predict(model, predictions, se.fit = TRUE)
  se_fit <- preds$se.fit
  
  predictions |> 
    mutate(fit = preds$fit,
           lwr = 1 - linkinv(fit + qt(.975, df) * se_fit),
           upr = 1 - linkinv(fit + qt(.025, df) * se_fit),
           fit = 1 - linkinv(fit)) |> 
    with({
      polygon(c(duration, rev(duration)), c(lwr, rev(upr)), border = NA, col = adjustcolor(col, .2))
      lines(duration, fit, col = col)
    })
}
```

The plot showing points estimates with confidence intervals from the data
together with the logistic regression prediction:

```{r}
plot(NA, xlim = c(0, 6), ylim = 0:1,
     xlab = "duration of treatment (months)",
     ylab = "proportion positive")

walk2(treatments, 1:4, add_data)
walk2(treatments, 1:4, add_model)
#walk2(treatments[c(2, 3)], c(2, 3), add_model)
```

## Another model


$$
N(t) = N_0 e^{-\lambda t}
$$

A function that gives CFU as a function of inital CFU, decay rate and time:

```{r}
cfu <- function(N0, lambda, t) {
  N0 * exp(- lambda * t)
}
```

Let's try it:

```{r}
cfu(1e4, .115, 30)
cfu(1e4, .115, c(30, 60))
```

A reparameterization

```{r}
rgamma2 <- function(n, mu, sigma) {
  rgamma(n, mu^2 / sigma^2, scale = sigma^2 / mu)
}
```

```{r}
dgamma2 <- function(x, mu, sigma) {
  dgamma(x, mu^2 / sigma^2, scale = sigma^2 / mu)
}
```

```{r}
pgamma2 <- function(q, mu, sigma) {
  pgamma(q, mu^2 / sigma^2, scale = sigma^2 / mu)
}
```

```{r}
qgamma2 <- function(p, mu, sigma) {
  qgamma(p, mu^2 / sigma^2, scale = sigma^2 / mu)
}
```

```{r}
cfu(1e4, qgamma2(.9, .115, .011), 30)
```


```{r}
lambda <- .3
sigma <- .011
N0 <- 1e4
epsilon <- 1e-16

cfu(N0, qgamma2(epsilon, lambda, sigma), 30)
cfu(N0, qgamma2(1 - epsilon, lambda, sigma), 30)
```

```{r}
distance_to_1 <- function(p, lambda, sigma, N0, t) {
  abs(1 - cfu(N0, qgamma2(p, lambda, sigma), t))
}
```

This function converts values for $\lambda$ and $\sigma$ to the probability
parameter of a binomial distribution:

```{r}
probability <- function(lambda, sigma, N0, t, epsilon = 1e-16) {
  upr <- cfu(N0, qgamma2(epsilon, lambda, sigma), t)
  if (upr < 1) {
    return(0)
  } else {
    lwr <- cfu(N0, qgamma2(1 - epsilon, lambda, sigma), t)
    if (lwr > 1) {
      return(1)
    }
    else {
      optimize(distance_to_1, 0:1, lambda = lambda, sigma = sigma, N0 = N0, t = t)$minimum
    }
  }
}
```

Let's try it:

```{r}
xs <- seq(.1, .5, le = 512)
plot(xs, map_dbl(xs, probability, sigma = .011, N0 = 1e4, t = 30, epsilon = 1e-16),
     type = "l", col = 4, lwd = 3, xlab = "sigma", ylab = "probability")
```

Minus log likelihood:

```{r}
mLL <- function(lambda, sigma, N0, data, epsilon = 1e-16) {
  - sum(dbinom(data$positive,
               data$total,
               map_dbl(data$duration, ~ probability(lambda, sigma, N0, .x * 30, epsilon)),
               TRUE))
}
```

Let's try it:

```{r}
mLL(lambda = .1, sigma = .011, N0 = 1e4, data = filter(table2, group == "RIF"), epsilon = 1e-16)
```

```{r}
f <- function(lambda = .1, sigma = .011, drug = "RIF", N0 = 1e4, epsilon = 1e-16) {
  data <- filter(table2, group == drug)
  mLL2 <- function(lambda, sigma) {
    mLL(lambda, sigma, N0, data, epsilon)
  }
  mle2(mLL2, start = list(lambda = lambda, sigma = sigma))
}

f(lambda = .1, sigma = .011, drug = "RIF", N0 = 1e4, epsilon = 1e-16)
```

```{r}

```




## Old code

Let's try it:

```{r}
hist(rgamma2(1e4, .115, .011))
```

Let's try it combined with the CFU function:

```{r}
plot(NA, xlim = c(0, 6 * 30), ylim = c(0, 1e4))
t_val <- seq(0, 6 * 30, le = 512)

lambda_val <- rgamma2(10, .115, .011)

map(lambda_val, ~ cfu(1e4, .x, t_val))
```


The log-likelihood function:

```{r}
LL <- function(mu, sigma, data, N0, lod, n) {
  sum(
    dbinom(
      data$positive,
      data$total,
      sum(cfu(N0, rgamma2(n, exp(mu), exp(sigma)), 30 * data$duration) > lod) / n,
      TRUE
    )
  )
}
```

Let's vizulize it:

```{r}
dt <- filter(table2, group == "RIF")
mu_val <- seq(.05, .3, le = 100)
LL_val <- map_dbl(mu_val, ~ LL(.x , .01, dt, 1e4, 1, 1e6))
plot(mu_val, LL_val)
```

The function that performs esimation:

```{r}
estimation <- function(drug, mu, sigma, N0, lod, n, ...) {
  data <- filter(table2, group == drug)
  mLL <- function(mu, sigma) {
    -sum(
      dbinom(
        data$positive,
        data$total,
        sum(cfu(N0, rgamma2(n, exp(mu), exp(sigma)), 30 * data$duration) > lod) / n,
        TRUE
      )
    )
  }
  mle2(mLL, list(mu = log(mu), sigma = log(sigma)), ...)
}
```

A function that converts estimates into data for a curve:

```{r}
estimates2ci <- function(x) {
  x |> 
    coef() |> 
    exp() |> 
    as.list() |> 
    with(rgamma2(10, mu, sigma)) |>
    map_dfc(~ cfu(N0, .x, t)) |> 
    t() |> 
    as.data.frame() |> 
    map_dfr(quantile, c(.025, .5, .975))
}
```

Let's try it:

```{r}
system.time(estimates <- estimation("RIF", mu = .15, sigma = .01, 1e4, lod = 1, n = 1e6))
estimates2ci(estimates)
```

Let's explore the quality of estimations:

```{r}
system.time(a1 <- replicate(10, estimation(treatments[1], mu = .05, sigma = .01, N0 = 1e4, lod = 1, n = 1e6, method = "Nelder-Mead")))
b1 <- bind_cols(exp(map_dfr(a1, coef)), map_dbl(a1, logLik))
```

```{r}
system.time(a2 <- mclapply(1:11, function(x) estimation(treatments[2], mu = .15, sigma = .01, N0 = 1e4, lod = 1, n = 1e6, method = "Nelder-Mead"), mc.cores = 11))
b2 <- bind_cols(exp(map_dfr(a2, coef)), map_dbl(a2, logLik), map_dbl(a2, ~ .x@details$convergence))
```

```{r}
a3 <- replicate(50, estimation(treatments[3], mu = .15, sigma = .01, 1e4, lod = 1, n = 1e4, method = "Nelder-Mead"))
b3 <- bind_cols(exp(map_dfr(a3, coef)), map_dbl(a3, logLik))
```

```{r}
a4 <- replicate(50, estimation(treatments[4], mu = .15, sigma = .01, 1e4, lod = 1, n = 1e4, method = "Nelder-Mead"))
b4 <- bind_cols(exp(map_dfr(a4, coef)), map_dbl(a4, logLik))
```



```{r}
arrange(b, ...3)[1, c("mu", "sigma")]
```

```{r}
estimation2 <- function(drug, mu0, sigma, N0, lod, n, nb) {
  out <- replicate(nb, estimation(drug, mu0, sigma, N0, lod, n, method = "Nelder-Mead"))
  out[[which.max(map_dbl(out, logLik))]]
}

estimation2(treatments[2], mu0 = .15, sigma = .01, N0 = 1e4, lod = 1, n = 1e4, nb = 50)
```





```{r}
points(arrange(b, ...3)[3, "mu"], arrange(b, ...3)[3, "sigma"], col = 4)

points(mean(b$mu), mean(b$sigma), col = 4, pch = 3)
```

```{r}
b2 <- filter(b, sort(-...3 - min(-b[[3]])) < 1e-6)
points(b2$mu, b2$sigma, col = 2)
```

